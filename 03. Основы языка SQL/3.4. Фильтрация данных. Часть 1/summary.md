# Фильтрация данных

- [Фильтрация данных](#фильтрация-данных)
  - [Используемая база данных](#используемая-база-данных)
  - [Оператор WHERE](#оператор-where)
  - [Операторы сравнения](#операторы-сравнения)
    - [Сравнение с одиночным значением](#сравнение-с-одиночным-значением)
    - [Сравнение с диапазоном значений](#сравнение-с-диапазоном-значений)
    - [Проверка на присутствие и отсутствие значения](#проверка-на-присутствие-и-отсутствие-значения)
  - [Примечания](#примечания)
    - [Примечание 1](#примечание-1)
    - [Примечание 2](#примечание-2)
    - [Примечание 3](#примечание-3)

## Используемая база данных

Перед тем как приступить к теме урока, рассмотрим базу данных, которая будет использоваться в последующих примерах. Она состоит из одной таблицы с именем `Songs`, которая содержит информацию о пяти наиболее популярных песнях на некоторой площадке для прослушивания музыки:

```sql
+----+-------+----------------------+------------+---------+--------------+
| id | place | trackname            | artist     | streams | release_date |
+----+-------+----------------------+------------+---------+--------------+
| 1  | 4     | Crazy On You         | Heart      | 76338   | NULL         |
| 2  | 3     | My Lover             | The Sounds | 99488   | NULL         |
| 3  | 2     | Running up That Hill | Kate Bush  | 121495  | 1985-08-05   |
| 4  | 5     | Thrill               | The Sounds | 49345   | 2016-11-10   |
| 5  | 1     | Spent the Day in Bed | Morrissey  | 174994  | 2017-09-19   |
+----+-------+----------------------+------------+---------+--------------+
```

Первое поле этой таблицы содержит идентификатор песни, второе — позицию песни в топе, третье — название песни, четвертое — псевдоним исполнителя или название группы, пятое — количество прослушиваний, шестое — дату выхода.

Скрипт для создания таблицы `Songs`:

```sql
DROP TABLE IF EXISTS Songs;
CREATE TABLE Songs
(
    id           INT PRIMARY KEY AUTO_INCREMENT,
    place        INT,
    trackname    VARCHAR(30),
    artist       VARCHAR(30),
    streams      INT,
    release_date DATE
);

INSERT INTO Songs (place, trackname, artist, streams, release_date)
VALUES (4, 'Crazy On You', 'Heart', 76338, NULL),
       (3, 'My Lover', 'The Sounds', 99488, NULL),
       (2, 'Running up That Hill', 'Kate Bush', 121495, '1985-08-05'),
       (5, 'Thrill', 'The Sounds', 49345, '2016-11-10'),
       (1, 'Spent the Day in Bed', 'Morrissey', 174994, '2017-09-19');
```

## Оператор WHERE

В таблицах баз данных обычно содержится очень много информации, и необходимость извлекать все записи из таблицы возникает довольно редко. Гораздо чаще требуется извлечь лишь некоторую их часть. Для этого используется оператор `WHERE`, который позволяет указывать определенные условия при извлечении записей. Если запись удовлетворяет этим условиям, то она попадает в результирующую таблицу, в противном случае отбрасывается.

В качестве первого примера напишем запрос, который извлекает данные о песнях некоторого конкретного исполнителя.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Songs
WHERE artist = 'The Sounds';
```

является:

```sql
+----+----------+-----------+------------+---------+--------------+
| id | place    | trackname | artist     | streams | release_date |
+----+----------+-----------+------------+---------+--------------+
| 2  | 3        | My Lover  | The Sounds | 99488   | NULL         |
| 4  | 5        | Thrill    | The Sounds | 49345   | 2016-11-10   |
+----+----------+-----------+------------+---------+--------------+
```

В данном примере используется простая проверка на равенство. Запрос извлекает все поля таблицы, но возвращает не все записи, а только те, значение поля `artist` которых равно строке `The Sounds`.

Также в примере выше следует обратить внимание на расположение оператора `WHERE` в запросе: он указывается после названия таблицы. Также оператор `WHERE` может использоваться совместно с оператором `ORDER BY`, в таком случае оператор `ORDER BY` должен располагаться после оператора `WHERE`.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Songs
WHERE artist = 'The Sounds'
ORDER BY streams;
```

является:

```sql
+----+----------+-----------+------------+---------+--------------+
| id | place    | trackname | artist     | streams | release_date |
+----+----------+-----------+------------+---------+--------------+
| 4  | 5        | Thrill    | The Sounds | 49345   | 2016-11-10   |
| 2  | 3        | My Lover  | The Sounds | 99488   | NULL         |
+----+----------+-----------+------------+---------+--------------+
```

## Операторы сравнения

Условие после оператора `WHERE` может являться не только проверкой на равенство. В SQL поддерживается целый набор операторов сравнения, которые перечислены в таблице ниже:

| Оператор      | Проверка |
| ------------- | -------- |
| `=`           | Равенство |
| `<=>`         | Эквивалентность |
| `!=`          | или <> Неравенство |
| `<`           | Меньше |
| `<=`          | Меньше или равно |
| `>`           | Больше |
| `>=`          | Больше или равно |
| `BETWEEN`     | Вхождение в диапазон |
| `IS NULL`     | Значение `NULL` |
| `IS NOT NULL` | Не значение `NULL` |

### Сравнение с одиночным значением

**Пример 1**. Извлечем из таблицы `Songs` данные о песнях, количество прослушиваний которых превышает `100000`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, streams
FROM Songs
WHERE streams > 100000;
```

является:

```sql
+----------------------+-----------+---------+
| trackname            | artist    | streams |
+----------------------+-----------+---------+
| Running up That Hill | Kate Bush | 121495  |
| Spent the Day in Bed | Morrissey | 174994  |
+----------------------+-----------+---------+
```

**Пример 2**. Извлечем из таблицы `Songs` данные о песнях, которые входят в тройку лучших композиций, и отсортируем их по занимаемой позиции.

Результатом приведенного ниже запроса:

```sql
SELECT place, trackname, artist
FROM Songs
WHERE place <= 3
ORDER BY place;
```

является:

```sql
+----------+----------------------+------------+
| place    | trackname            | artist     |
+----------+----------------------+------------+
| 1        | Spent the Day in Bed | Morrissey  |
| 2        | Running up That Hill | Kate Bush  |
| 3        | My Lover             | The Sounds |
+----------+----------------------+------------+
```

**Пример 3**. Извлечем из таблицы `Songs` данные о песнях, которые не принадлежат группе `The Sounds`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist
FROM Songs
WHERE artist != 'The Sounds';
```

является:

```sql
+----------------------+-----------+
| trackname            | artist    |
+----------------------+-----------+
| Crazy on You         | Heart     |
| Running up That Hill | Kate Bush |
| Spent the Day in Bed | Morrissey |
+----------------------+-----------+
```

> Операторы `!=` и `<>` обычно взаимозаменяемы, однако не во всех СУБД поддерживаются обе формы оператора.

### Сравнение с диапазоном значений

Для сравнения с диапазоном значений используется оператор `BETWEEN`. Его синтаксис немного отличается от других операторов, так как для него требуются два значения: начальное и конечное.

**Пример 1**. Извлечем из таблицы Songs данные о песнях, количество прослушиваний которых находится в диапазоне `[50000; 100000]`.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, streams
FROM Songs
WHERE streams BETWEEN 50000 AND 100000;
```

является:

```sql
+--------------+------------+---------+
| trackname    | artist     | streams |
+--------------+------------+---------+
| Crazy on You | Heart      | 76338   |
| My Lover     | The Sounds | 99488   |
+--------------+------------+---------+
```

Как видно из примера выше, при использовании оператора `BETWEEN` нужно указывать два значения: нижнюю и верхнюю границы диапазона. Оба значения должны быть разделены ключевым словом `AND`. При этом извлекаются все значения из диапазона, включая те, что равны граничным значениям.

**Пример 2**. Извлечем из таблицы `Songs` данные о песнях, которые занимают второе, третье и четвертое места, и отсортируем их по занимаемой позиции.

Результатом приведенного ниже запроса:

```sql
SELECT place, trackname, artist
FROM Songs
WHERE place BETWEEN 2 AND 4
ORDER BY place;
```

является:

```sql
+----------+----------------------+------------+
| place    | trackname            | artist     |
+----------+----------------------+------------+
| 2        | Running up That Hill | Kate Bush  |
| 3        | My Lover             | The Sounds |
| 4        | Crazy on You         | Heart      |
+----------+----------------------+------------+
```

### Проверка на присутствие и отсутствие значения

Чтобы проверить, содержит ли поле значение `NULL`, нельзя просто записать `<название поля> = NULL`, поскольку значение `NULL` трактуется как неопределенное, и мы не можем выполнить проверку такого значения ни на равенство, ни на неравенство.

Для определения того, находится ли в поле значение `NULL`, предусмотрен оператор `IS NULL`. Противоположным для него оператором является `IS NOT NULL`, который позволяет определить, что в поле не находится значение `NULL`.

**Пример 1**. Извлечем из таблицы `Songs` данные о песнях, которые не имеют даты выхода.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, release_date
FROM Songs
WHERE release_date IS NULL;
```

является:

```sql
+--------------+------------+--------------+
| trackname    | artist     | release_date |
+--------------+------------+--------------+
| Crazy on You | Heart      | NULL         |
| My Lover     | The Sounds | NULL         |
+--------------+------------+--------------+
```

**Пример 2.** Извлечем из таблицы `Songs` данные о песнях, которые имеют дату выхода, и отсортируем их по этой дате в порядке убывания.

Результатом приведенного ниже запроса:

```sql
SELECT trackname, artist, release_date
FROM Songs
WHERE release_date IS NOT NULL
ORDER BY release_date DESC;
```

является:

```sql
+----------------------+------------+--------------+
| trackname            | artist     | release_date |
+----------------------+------------+--------------+
| Spent the Day in Bed | Morrissey  | 2017-09-19   |
| Thrill               | The Sounds | 2016-11-10   |
| Running up That Hill | Kate Bush  | 1985-08-05   |
+----------------------+------------+--------------+
```

## Примечания

### Примечание 1

Фильтрация данных может выполняться после извлечения на уровне приложения, работающего с этими данными. Но такой метод обычно не приветствуется, так как базы данных оптимизированы для быстрой и эффективной фильтрации, и выполнение приложением функций базы данных приведет к значительному снижению его производительности.

### Примечание 2

Псевдонимы полей не могут быть использованы в блоке оператора `WHERE` для фильтрации записей.

Результатом приведенного ниже запроса:

```sql
​SELECT trackname, artist, streams AS auditions
FROM Songs
WHERE auditions > 100000;
```

является ошибка:

```sql
ERROR 1054: Unknown column 'auditions' in 'where clause'
```

Это связано с тем, что блок `WHERE` обрабатывается до блока `SELECT`, поэтому на момент выполнения блока `WHERE` псевдонимы полей еще не известны.

### Примечание 3

По умолчанию операторы сравнения не учитывают регистр при сравнении строковых значений.

Результатом приведенного ниже запроса:

```sql
SELECT 'bee' = 'Bee',
       'bee' <=> 'Bee',
       'bee' > 'Bee',
       'bee' < 'Bee';
```

является:

```sql
+---------------+-----------------+---------------+---------------+
| 'bee' = 'Bee' | 'bee' <=> 'Bee' | 'bee' > 'Bee' | 'bee' < 'Bee' |
+---------------+-----------------+---------------+---------------+
| 1             | 1               | 0             | 0             |
+---------------+-----------------+---------------+---------------+
```

Для учета регистра необходимо использовать ключевое слово `BINARY`, которое располагается перед левым операндом.

Результатом приведенного ниже запроса:

```sql
SELECT BINARY 'bee' = 'Bee',
       BINARY 'bee' <=> 'Bee',
       BINARY 'bee' > 'Bee',
       BINARY 'bee' < 'Bee';
```

является:

```sql
+----------------------+------------------------+----------------------+----------------------+
| BINARY 'bee' = 'Bee' | BINARY 'bee' <=> 'Bee' | BINARY 'bee' > 'Bee' | BINARY 'bee' < 'Bee' |
+----------------------+------------------------+----------------------+----------------------+
| 0                    | 0                      | 1                    | 0                    |
+----------------------+------------------------+----------------------+----------------------+
```
